Данный раздел разделен на несколько частей(каждый пункт - это ссылка на соответствующий раздел):

[Типи даних в Python](#%D0%A2%D0%B8%D0%BF%D0%B8-%D0%B4%D0%B0%D0%BD%D0%B8%D1%85-%D0%B2-Python)
  * [Числа (numbers)](#%D0%A7%D0%B8%D1%81%D0%BB%D0%B0-%28numbers%29)
    * Целые числа
    * Дробные числа
  * [Строки (Strings)](#%D0%A1%D1%82%D1%80%D0%BE%D0%BA%D0%B8-%28Strings%29)
    * Сырые строки
    * Индексы и слайсы
    * Операции
    * Форматирование
    * Приведение типов в строку
  * Списки (lists)
    * Некоторые методы списков
  * Множества (set)
  * Словари (dict)
    * Функции словарей
  * Изменяемость списков, словарей, множеств
  * Кортежи (tuple)
  * Frozenset



# Типы данных в Python


## Числа (numbers)
<details><summary><b>Нажать, чтобы раскрыть</b></summary>

### Целые числа
Целые числа в Python, это числа без дробной части. Они могут быть положительными или отрицательными. Например, 2, -2, 0, 1000.

Целые числа в Python задаются следующим образом:

```python
number = 123
```

Python, так же как и любой другой язык программирования, позволяет работать с целыми числами и совершать операции между ними. Базовые операции с целыми числами в Python выглядят следующи образом:

```python
# Сложение
number = 123 + 321

# Вычитание
number = 123 - 321

# Деление
number = 123 / 321

# Целочисленное деление (возвращает целую часть от деления)
number = 123 // 321

# Остаток от деления (возвращает остаток от деления)
number = 123 % 321

# Умножение
number = 123 * 321

# Возведение в степень (возводит число в степень)
number = 123 ** 321

# Математические выражение выполняются по правилам арифметики (сначала умножение и деление, потом сложение и вычитание), но при необходимости можно использовать скобки для изменения порядка выполнения операций.
number = (123 + 321) * 213
```

Для того чтобы записать в двоичной системе, необходимо использовать префикс `0b`:

```python
number = 0b1010  # (это число в десятичной системе равно 10)
```

Для того чтобы записать в восьмеричной системе, необходимо использовать префикс `0o`:

```python
number = 0o12  # (это число в десятичной системе равно 10)
```

Для того чтобы записать в шестнадцатеричной системе, необходимо использовать префикс `0x`:

```python
number = 0xA  # (это число в десятичной системе равно 10)
```


### Дробные числа
Дробные числа это числа с дробной частью. Они могут быть положительными или отрицательными. Например, 2.6, -2.0, 0.0, 1000.0. И записываются с помощью точки.
Дробные числа в Python задаются следующим образом:

```python
number = 123.321
```

Дробные или вещественные числа в Python поддерживают те же операции, что и целые. 

> **Важно отметить:** Из-за особенности представления чисел в компьютере, вещественные числа могут быть неточными и приводить к ошибкам.

Пример:
```python
>>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1
0.9999999999999999
```
*Мы ожидали получить 1, но результат оказался приближенным*


Ряд специальных операций позволяет сразу присваивать результат математического выражения:

```python
# Присвоение результата сложения
number += 1

# Присвоение результата вычитания
number -= 1

# Присвоение результата умножения 
number *= 1

# Присвоение результата деления
number /= 1

# Присвоение результата целочисленного деления
number //=

# Присвоение результата возведения числа в степень
number **=

# Присвоение результата остатка от деления
number %=
```

### Модуль math

<details><summary><b>Модуль math(нажмите для открытия)</b></summary>

Модуль `math` содержит в себе большое количество функций для работы с числами и включает сложные математические операции.
Для того чтобы использовать функции из модуля `math`, его необходимо импортировать и можно использовать следующие вызовы:

```python
import math

# Вывод числа пи
math.pi

# Возведение числа X в степень Y
math.pow(X, Y)

# Факториал числа X
math.factorial(X)

# Модуль числа X
math.fabs(X)

# Округление X до ближайшего большего числа
math.celi(X)

# Округление X вниз
math.floor(X)
```
</details>

### Модуль random

<details><summary><b>Модуль random(нажмите для открытия)</b></summary>
Для генерации случайных данных можно использовать модуль `random`. Он содержит в себе большое количество функций для генерации случайных чисел, выбора случайных элементов из последовательности и т.д.
Чтобы использовать функции из модуля `random`, его необходимо импортировать и можно использовать следующие вызовы:

```python

import random

# Генерация случайного целого числа в диапазоне от 1 до 10
a = random.randint(1, 10)
```
> **Важно:** Нужно помнить что в авто тестах использование случайных данных не рекомендуется, так как это может привести к непредсказуемому поведению тестов, так как мы не можем контролировать входные данные. 
> Или же в случае использования случайных данных, их нужно контролировать, как например в случае генерации случайных чисел, но в заданном диапазоне. Это нужно для того чтобы тесты были предсказуемыми(что числа точно будут в данном диапазоне, а не в разброс от 1 до 10000000) и стабильными.
> Чтобы получить стабильные рандомные данные, нужно использовать seed, который будет генерировать одинаковые данные при каждом запуске тестов.
Следующий пример показывает как использовать seed:

```python
import random

random.seed(1) # В скобках указывается любое значение(число или строка), которое будет использоваться для генерации случайных чисел
print(random.randint(1, 10))  # 3
```
</details>

### Модуль Faker 

<details><summary><b>Модуль Faker(нажмите для открытия)</b></summary>
Модуль `Faker` позволяет генерировать случайные данные, такие как имена, адреса, тексты, числа и т.д. Это может быть полезно для генерации тестовых данных, например для тестирования форм, где нужно вводить данные пользователя.
Для того чтобы использовать функции из модуля `Faker`, его необходимо импортировать и можно использовать следующие вызовы:

```python
from faker import Faker

fake = Faker()

# Генерация случайного имени
fake.name()

# Генерация случайного адреса
fake.address()
```

</details>

### Функция round

Функция `round` позволяет округлить число до заданного количества знаков после запятой. По умолчанию округление происходит до целого числа.

```python
# Округление числа до целого
round(1.5)  # 2

# Округление числа до 2 знаков после запятой
round(1.333333, 2)  # 1.33
```
</details>

## Строки (strings)
<details><summary><b>Нажать, чтобы раскрыть</b></summary>
Строки в Python это последовательность символов, которые могут быть буквами, цифрами, знаками препинания и т.д и задаются с помощью кавычек.
Строки в Python задаются одним из следующих образов:

```python
s = "Python"
s = 'Python'
```
Кавычки могут быть одинарными, двойными или тройными. При этом важно чтобы открывающая и закрывающая кавычки были одинаковыми.
При использовании одинарных кавычек в строке можно использовать двойные и наоборот.

```python
s = "I'm a string"
s = 'I"m a string'
```
Чтобы использовать одинарные и двойные кавычки в одной строке, можно использовать экранирование.
Экранирование это специальные символы, которые позволяют использовать символы, которые обычно не могут быть использованы в строках.
Пример использования экранирования:

```python
s = "I'm a string with \"quotes\""
s = 'I"m a string with \'quotes\''
```
Где `\"` и `\'` это экранированные символы, которые позволяют использовать кавычки в строке.

Многострочные строки можно задавать следующим образом:

```python
multiline_string = """first
second
third"""

multiline_string = "first\nsecond\nthird"

multiline_string = "first\n" \
                   "second\n" \
                   "third"
```

### Сырые строки

Сырые строки это строки, в которых экранированные символы не обрабатываются и позволяют использовать специальные символы в строке.
Сырые строки задаются с помощью префикса `r` перед строкой:

```python
s = r"I'm a string with \"quotes\""
```
Или же с помощью экранирования:

```python
s = 'first \\nsecond \\nthird'
```

### Индексы и слайсы(срезы)
Индексы в Python позволяют получать доступ к отдельным символам строки. Слайсы позволяют получать доступ к нескольким символам строки.
Элементы строк в Python индексируются с нуля. Поэтому если необходимо получить из строки первый элемент, то запросить надо нулевой.

```python
s = "abcdefg"
print(s[0])
```

Также можно получить элементы с конца строки, используя отрицательные индексы:

```python
s = "abcdefg"
print(s[-1])
```

> **Важно:** 
> Индексы с конца строки начинаются с -1, что позволяет удобно получать элементы с конца строки.
> А индексы с начала строки начинаются с 0.

Также есть возможность получить не один символ из строки, а сразу несколько. При этом для этого в Python можно обойтись без циклов и воспользоваться встроенным решением.

```python
s[x:y:z]

"""
Где:
x — начальный индекс;
y — конечный индекс(не включительно);
z — шаг(по умолчанию 1).
"""
```

Примеры:
```python
s = "abcdefg"

print(s[0:3])
abc

print(s[0:-1])
abcdef

print(s[0:-1:2])
ace
```
Значение 0 в срезе можно опустить, так как оно подразумевается по умолчанию:

```python
s = "abcdefg"

print(s[:3])
abc
```

Также можно получить все элементы строки с начала до конца:

```python
s = "abcdefg"

print(s[:])
abcdefg
```

Можно получить все элементы строки с конца до начала, в обратном порядке:

```python
s = "abcdefg"

print(s[::-1])
gfedcba
```


### Операции

Все операции, которые можно совершать со строками доступны через точку после строки:

```python
# Замена слов в строке
>>> "Hello, world!".replace("Hello", "Bye")
Bye, world!

# Разделение строки 
"Hello, world!".split()

# Проверка начала строки 
"Hello, world!".startswith("Hello")

# Первый символ строки заглавный
>>> "hello, world!".capitalize()
Hello, world!

# Все символы заглавными буквами
>>> "hello, world!".upper()
HELLO, WORLD!

# Все символы строчными буквами
>>> "HELLO, WORLD!".lower()
hello, world!

# Проверка на то, что строка состоит только из букв
>>> "Hello, world!".isalpha()
False

# Проверка на то, что строка состоит только из цифр
>>> "123".isdigit()
True
```

### Форматирование

Форматирование в Python позволяет удобно склеивать строки и вставлять в них значения переменных.
В Python есть несколько способов «склеивания» строк:

```python
# Строки без переменных
>>> print("first " "second " "third ")
first second third 

# Строки в переменных
first = "first"
second = "second"
third = "third"

>>> print(first + second + third)
firstsecondthird

# С пробелами
>>> print(first + " " + second + " " + third)
first second third
```

Для более удобной конкатенации («склеивания») строк в Python предусмотрены так называемые `f-строки`:

```python
first = "first"
second = "second"
third = "third"

# Без пробелов
>>> print(f"{fist}{second}{third}")
firstsecondthird

# С пробелами
>>> print(f"{first} {second} {third}")
first second third
```

Внутри фигурных скобок можно вызывать функции и выполнять выражения:

```python
>>> print(f"{first} {second} {third.upper()} {10 + 10}")
first second THIRD 20
```

До появления `f-строк` в Python был доступен следующий способ форматирования(format):

```python
>>> print("{} {} {}".format(first, second, third))
first second third
```

```python
url_template = "https://yourserver.com/v1/api/{}"
users_url = url_template.format("users")
groups_url = url_template.format("groups")

>>> print(users_url)
https://yourserver.com/v1/api/users
>>> print(groups_url)
https://yourserver.com/v1/api/groups
```

Доступен и еще более старый способ форматирования, который иногда встречается в проектах:

```python
print("%s %s %s" % (first, second, third))
first second third
```

Приведение типов в строку:

```python
s = "123"
n = 123

assert s == n  # Будет ошибка, так как типы разные
assert s == str(n)  # Переменную n приводим к строке и сравниваем. Будет истина, так как n приведено к строке
assert int(s) == n  # Переменную s приводим к числу и сравниваем. Будет истина, так как s приведено к числу
```

Проверка на то, что переменная состоит только из цифр:

```python
s = "123"
s.isdigit()  # Если True, то переменная состоит только из цифр
```

Проверка на то, что переменная состоит только из букв:

```python
s = "123ffsdfs"
s.isalpha()  # Если True, то переменная состоит только из букв
```
</details>

## Списки (lists)
<details><summary><b>Нажать, чтобы раскрыть</b></summary>

Составные типы данных в Python это списки, кортежи, словари и множества. В данном разделе рассмотрим списки.
Списки в Python задаются с помощью квадратных скобок (`[]`). Содержимым списков могут быть любые типы данных и даже сами списки. При этом один список может содержать в себе сразу несколько типов данных.

```python
l = ["list", 123, 12.3, ["another_list", 321]]
```

Пустой список задается следующим образом:

```python
l = []
```

Также список можно задать следующим образом:
```python
l = list("first")

>>> print(l)
['f', 'i', 'r', 's', 't']
```

Списки поддерживают индексы и слайсы, что позволяет удобно работать с их содержимым:

```python
l = ["first", "second", "third", ["another_list", 321]]

>>> print(l[0]) # Получение первого элемента
first

>>> print(l[0:2]) # Получение первых двух элементов
['first', 'second']

>>> print(l[-1]) # Получение последнего элемента
['another_list', 321]

>>> print(l[-1][0]) # Получение элемента из вложенного списка
another_list
```

> **Важно учесть:** У списков нет размерности, что позволяет удобно с ними работать. При этом надо внимательнее следить за размером содержимого списков. Нумерация списков начинается с нуля и списки поддерживают слайсы.

### Некоторые методы списков

```python
# Добавление элемента x в конец списка
list.append(x)

# Расширение списка list элементами списка L
list.extend(L)

# Вставка на i-ое место списка элемента x
list.insert(i, x)

# Удаление первого элемента в списке со значением x
list.remove(x)

# Возвращение количества элементов списка list со значением x
list.count(x)

# Разворачивание списка в обратном порядке
list.reverse()

# Очистка списка
list.clear()

# Сортировка списка
list.sort()

len(list)  # Возвращает длину списка

```
Чтобы удалить дубликаты из списка, можно воспользоваться множеством:

```python
l = [1, 2, 3, 4, 5, 5, 5, 5, 5]
l = list(set(l)) # Удаляет дубликаты из списка, так как множество не содержит дубликатов. После чего преобразует множество обратно в список, но при этом порядок элементов может измениться
[1, 2, 3, 4, 5]
```
</details>

## Множества (set)
<details><summary><b>Нажать, чтобы раскрыть</b></summary>

Множества в Python это неупорядоченные коллекции уникальных элементов.
Множества в Python задаются с помощью фигурных скобок (`{}`):

```python
s1 = {1, 2, 3, 4, 5}
s2 = {1, 2, 3, 4, 5, 5, 5, 5, 5} # При этом все дубликаты будут удалены
```

Множества поддерживают операции объединения, пересечения и разности:

```python
s1 = {1, 2, 3, 4, 5}
s2 = {4, 5, 6, 7, 8}

# Объединение множеств
s3 = s1 | s2 или s1.union(s2)
print(s3)
{1, 2, 3, 4, 5, 6, 7, 8}

# Пересечение множеств
s3 = s1 & s2  или s1.intersection(s2)
print(s3)
{4, 5}

# Разность множеств
s3 = s1 - s2 или s1.difference(s2)
print(s3)
{1, 2, 3}

s1.intersection(s2)  # Пересечение множеств
```
</details>

## Словари (dict)
<details><summary><b>Нажать, чтобы раскрыть</b></summary>

Словари в Python представляют собой неупорядоченные коллекции произвольных объектов с доступом по ключу. Часто их называют хеш-таблицами или массивами.

Задать словарь можно следующим образом:

```python
d = {
    "key": "value"
}
```

Получать значения можно по ключу. Для этого достаточно обратиться к ключу:

```python
d = {
    "name": "John",
    "age": 30
}

>>> print(d["name"])
John
>>> print(d["age"])
30
```
Также можно изменить значение по ключу:

```python
d = {
    "name": "John",
    "age": 30
}

d["name"] = "Mike"
print(d["name"])
Mike
```

Добавить новую пару ключ-значение можно следующим образом:

```python
d = {
    "name": "John",
    "age": 30
}

d["city"] = "New York"
print(d)
{'name': 'John', 'age': 30, 'city': 'New York'}
```

Удалить пару ключ-значение можно следующим образом:

```python
d = {
    "name": "John",
    "age": 30
}

del d["name"]
print(d)
{'age': 30}
```

При работе с вложенными словарями можно использовать следующий синтаксис:

```python
d = {
    "name": "John",
    "age": 30,
    "address": {
        "city": "New York",
        "street": "Broadway"
    }
}

print(d["address"]["city"])
New York
```

Можно отдельно получить список ключей и значений, что позволяет удобно работать с ними:

```python
print(d.keys()) # Получение списка ключей
print(d.values()) # Получение списка значений
```

Пары значений можно получить следующим образом:
```python
>>> print(d.items()) # Получение списка пар ключ-значение в виде кортежей
dict_items([('name', 'John'), ('age', 30)])
```

Можно проверить наличие ключа в словаре:

```python
d = {
    "name": "John",
    "age": 30
}

print("name" in d)  # True
print("city" in d)  # False
```


### Функции словарей

```python
d = {
    "name": "John",
    "age": 30
}

# Получение значения по ключу. 
>>> print(d.get("name"))
John


# Получение значения по ключу, если его нет, то возвращает значение по умолчанию
>>> print(d.get("name", "Mike"))
John

# Получение значения по ключу, которого нет в словаре и вставка значения по умолчанию
>>> print(d.get("city", {"city": "New York"}))
{'city': 'New York'}

# Удаление пары ключ-значение по ключу. Возвращает значение по ключу
>>> print(d.pop("name"))
John
>>> print(d) # Что осталось в словаре после удаления
{'age': 30}

# Удаление всех пар ключ-значение
>>> print(d.clear())
None
>>> print(d)
{}

# Копирование словаря
>>> print(d.copy())
{'name': 'John', 'age': 30}
print(d)
{'name': 'John', 'age': 30}


# Обновление словаря
d.update({"name": "Mike"})

```
</details>

## Изменяемость списков, словарей, множеств
<details><summary><b>Нажать, чтобы раскрыть</b></summary>

Списки, словари и множества являются изменяемыми объектами, что позволяет изменять их содержимое. Это означает, что при изменении списка, словаря или множества, изменения будут происходить в самом объекте, а не в его копии.

Следующий пример показывает, что при изменении списка, изменения происходят в самом списке:

```python
l1 = [1, 2, 3, 4, 5]
l2 = l1
l2.append(6)
print(l1)  # [1, 2, 3, 4, 5, 6]
print(l2)  # [1, 2, 3, 4, 5, 6]
```

Также это относится и к словарям и множествам:
```python
d1 = {"name": "John", "age": 30}
d2 = d1
d2["city"] = "New York"
print(d1)  # {'name': 'John', 'age': 30, 'city': 'New York'}
print(d2)  # {'name': 'John', 'age': 30, 'city': 'New York'}
```

```python
s1 = {1, 2, 3, 4, 5}
s2 = s1
s2.add(6)
print(s1)  # {1, 2, 3, 4, 5, 6}
print(s2)  # {1, 2, 3, 4, 5, 6}
```
Чтобы создать копию списка, словаря или множества, можно использовать следующий синтаксис:

```python
l1 = [1, 2, 3, 4, 5]
l2 = l1.copy()
l2.append(6)
print(l1)  # [1, 2, 3, 4, 5]
print(l2)  # [1, 2, 3, 4, 5, 6]

d1 = {"name": "John", "age": 30}
d2 = d1.copy()
d2["city"] = "New York"
print(d1)  # {'name': 'John', 'age': 30}
print(d2)  # {'name': 'John', 'age': 30, 'city': 'New York'}

s1 = {1, 2, 3, 4, 5}
s2 = s1.copy()
s2.add(6)
print(s1)  # {1, 2, 3, 4, 5}
print(s2)  # {1, 2, 3, 4, 5, 6}
```

Со вложенными списками, словарями и множествами ситуация несколько сложнее. При изменении вложенного объекта, изменения будут происходить в самом объекте, а не в его копии:

```python
l1 = [1, 2, 3, [4, 5, 6]]
l2 = l1.copy()
l2[3].append(7)
print(l1)  # [1, 2, 3, [4, 5, 6, 7]]    
print(l2)  # [1, 2, 3, [4, 5, 6, 7]]
```

Чтобы создать копию вложенного списка, словаря или множества, можно использовать следующий синтаксис:

```python
import copy

l1 = [1, 2, 3, [4, 5, 6]]
l2 = copy.deepcopy(l1)
l2[3].append(7)
print(l1)  # [1, 2, 3, [4, 5, 6]]
print(l2)  # [1, 2, 3, [4, 5, 6, 7]]
```
</details>

## Кортежи (tuple)
<details><summary><b>Нажать, чтобы раскрыть</b></summary>

Кортежи представляют собой списки, которые нельзя менять. Во многих случаях кортежи занимают меньше места в памяти, чем списки, а задаются следующим образом:

```python
t = (1, 2, 3, 4, 5)
```

Над кортежами можно применять любые операции, не изменяющие список(например, получение элементов по индексу, слайсы и т.д).

При присвоении кортежа новой переменной, создается новый кортеж, а не его копия:

```python
t1 = (1, 2, 3, 4, 5)
t2 = t1
t2 += (6, 7, 8) # При этом создается новый кортеж, а не изменяется старый. Данный синтаксис эквивалентен t2 = t2 + (6, 7, 8)
print(t1)  # (1, 2, 3, 4, 5)
print(t2)  # (1, 2, 3, 4, 5, 6, 7, 8)
```
</details>


## Frozenset
<details><summary><b>Нажать, чтобы раскрыть</b></summary>

`Frozenset` это неизменяемое множество, которое задается следующим образом:

```python
f = frozenset([1, 2, 3, 4, 5])
```

`Frozenset` поддерживает те же операции, что и множества, но при этом не поддерживает операции, которые изменяют множество.
</details>

##  Подсказка к домашнему заданию

<details><summary><b>Смотрите только когда не можете понять что делать(нажать, чтобы раскрыть)</b></summary>

В тесте `test_random_list` нужно создать список из 10 случайных чисел от 1 до 100 (включая обе границы) и отсортировать его по возрастанию.

```python
def test_random_list():
    """
    Создайте список из 10 случайных чисел от 1 до 100 (включая обе границы) и отсортируйте его по возрастанию.
    """
    # TODO создайте список
    l = []
```
Чтобы не создавать дубли кода, и не писать вручную 10 раз:

```python
l1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
l2 = [5, 7, 9, 12, 99, 66, 80, 39, 99, 100]
l3 = [4, 5, 9, 19, 20, 21, 22, 23, 24, 25]
l4 = [1, 88, 8, 66, 55, 44, 33, 22, 11, 10]
l5 = [70, 71, 72, 73, 74, 75, 76, 77, 78, 79]
l6 = [55, 59, 63, 67, 71, 75, 79, 83, 87, 91]
l7 = [4, 8, 12, 16, 20, 24, 28, 32, 36, 40]
l8 = [7, 14, 21, 28, 35, 42, 49, 56, 63, 70]
l9 = [99, 98, 97, 96, 95, 94, 93, 92, 91, 90]
l10 = [5, 15, 25, 35, 45, 55, 65, 75, 85, 95]
```

Можно использовать функцию `random.randint` из модуля `random` как в примере ниже:

```python
import random

def test_random_list():
    """
    Создайте список из 20 случайных чисел от 5 до 200 (включая обе границы)
    """
    # TODO создайте список
    l = [random.randint(5, 200) for _ in range(20)]
    print(l)

Результат:
[103, 199, 112, 15, 71, 135, 129, 108, 82, 127, 96, 154, 60, 134, 40, 77, 40, 198, 29, 163]
```

Или можно использовать random.sample для получения уникальных случайных чисел:
random.sample - это функция, которая возвращает список уникальных случайных чисел из диапазона.

```python

import random

def test_random_list():
    """
    Создайте список из 20 случайных чисел от 2 до 200 (включая обе границы)
    """
    # TODO создайте список
    l = random.sample(range(2, 201), 20) # Указано 201, так как второй аргумент всегда не включается(-1)
    print(l)
```


Чтобы отсортировать список, можно использовать метод `sort`:

```python
l.sort()  # Сортировка списка по возрастанию
```

Сортировка списка по убыванию:

```python
l.sort(reverse=True)
```

</details>