## Особенность Selene

Задача Selene говорить на языке пользователя, поэтому обращаться с его методами просто, и многие из них читаются практически также, как на естественном языке. 

Примеры:

```python
# Название вкладки должно содержать текст «ToolsQA»
browser.should(have.title('ToolsQA'))

# Элемент по селектору «main-header» должен содержать текст «Box»
browser.element('[class="main-header"]').should(have.text('Box'))
```

Важно отметить, что Selene работает с CSS-селекторами и XPath.

## CSS-селекторы

> **Важно:** поиск по классу начинается с символа `.`, а поиск по ID с `#`.

CSS-селекторы позволяют обращаться к различным элементам страницы и выполнять с ними различные действия. В примере выше CSS-селектор `main-header` указан после слова `element`: `browser.element('[class="main-header"]')`. В данном случае мы обращаемся к элементу по атрибуту и его значению, где `class` — атрибут, а `main-header` — значение. 

Можно не указывать значение. Но тогда найдутся все элементы с указанным атрибутом. К примеру, `browser.element('[class]')`.

Можно указать элемент ещё более точно и обратиться не просто к атрибуту и значению, но и к его тегу, К примеру, `browser.element('[div[class="main-header"]')`. Но важно помнить, чтобы селекторы были стабильными и не стоит использовать очень длинные и точные описания. Достаточно указать уникальные атрибуты.

В наилучшем варианте стоит договориться с разработчиками, чтобы они сами указывали в коде проекта уникальные атрибуты для тестирования, которые никогда не будут меняться и использоваться только для целей тестирования.

Если значение атрибута состоит из нескольких слов, то мы можем обратиться только по основному. Для этого понадобится символ тильды (`~`). К примеру, в коде мы имеем селектор `cursive main-header bold`. Обратиться к нему можно `browser.element('[class~=main-header]')`. Можно ещё сократить и написать `browser.element('[.main-header]')`.

Ещё можно обращаться следующим образом: `browser.element('[id=userName]')`. Если сократить, то выйдет вот так: `browser.element('[#userName]')`.

## Что делать с дублирующими ID
Бывает такое, что разные элементы имеют в коде одинаковые ID. Поэтому если обращаться к этому элементу, то система всегда будет брать самый первый, который найдёт. Для решения этой проблемы есть несколько способов:

- Указать номер элемента   
`browser.all('#currentAddress')[1]`
- Найти элемент в два подхода   
`browser.element('#output #currentAddress')`  или `browser.element('#output').element('#currentAddress')`

## XPath-селекторы

**Примеры отличия XPath-селекторов от CSS-селекторов:**

| CSS                          | XPath                                  |
|------------------------------|----------------------------------------|
| browser.element('#userName') | browser.element('//*[@id="userName"]') |
| browse.all('#output p')      | browser.all('//*[@id="output"]//p')    |


В большинстве случаев удобнее и читабельнее использовать именно CSS-селекторы, но иногда бывают нужен именно XPath. Особенно в тех случаях, когда необходимо искать элемент по тексту.

## Как изменить размер окна браузера
Для этого необходимо перейти в фикстуру с конфигурацией и указать следующую строки с кодом:

```
browser.config.window_width = 1920
browser.config.window_height = 1080
```
